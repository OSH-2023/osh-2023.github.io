# 必做部分
在 socket 简介一节，我们给出了一个简易的 HTTP Server 原型，它能够一个接一个的处理请求，当 `handle_clnt` 正在运行时，新的请求将被放置于请求缓冲区，在当前请求处理完成后，才会进行下一个请求的处理。

另外，这个版本的 HTTP 服务器存在以下问题：

- 没有实现并发处理，当客户端发送数据过慢时，新的请求等待时间过长；
- 没有很好的解析和检验 HTTP 头；
- 没有实现读取请求资源内容的功能；
- 没有实现返回不同的 HTTP 状态码；
- 没有实现错误和异常处理；

为了解决以上问题，本实验要求同学们在理解示例代码的基础上，实现一个高性能 HTTP Server，能尽可能准确、快速处理并发的请求。

## 多进程和多线程

示例代码中，请求是顺序阻塞进行解析响应，这极大拖慢了 Server 的响应速度，我们可以将处理响应的部分移至新线程或新进程中处理，如：`fork()` 创建新进程来处理请求，也可以用 `pthread` 来创建新线程，这样能大大提高 Server 的并发性能，在多个请求到达时也能快速响应。

请同学们自行选择一种方案，说明理由，并用代码实现。

## 解析和检验 HTTP 头

目前 `parse_request()` 只能处理正确的请求，对于畸形的请求，可能会造成严重问题，请根据 HTTP 协议简介一节完善这一部分的代码，使得对 HTTP 请求的检查更健壮，对于畸形的请求，可以返回 `500 Internal Server Error`。

## 实现读取请求资源内容

真正的 HTTP Server 会尝试返回用户请求的资源内容（文件内容），请参考 Python Server 的行为，实现这一部分内容。

例如：

- 请求的资源路径是 `/index.html` 则尝试返回当前运行目录下的 `index.html` 文件的内容；
- 请求的资源路径是一个目录，则返回 500 错误；

注意：

- 资源文件根目录为程序运行时的当前目录；
- 返回头仅要求完成  `Content-Length`；
- 当请求的资源（文件）不存在时，可以返回 `404 Not Found`；
- 当出现其他错误时，可以返回 `500 Internal Server Error`；

## 实现错误和异常处理

示例代码中没有对各种错误和异常做良好的处理，请根据各个调用可能出错的情况进行分析，使得 Server 尽可能健壮，不会运行时崩溃，提高 Server 的可用性。